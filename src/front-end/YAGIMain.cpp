#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <assert.h>
#include <algorithm>
#include <memory>
#include <fstream>
#include <streambuf>

#include "autoGenerated/YAGILexer.h"
#include "autoGenerated/YAGIParser.h"
#include "autoGenerated/YAGITreeWalker.h"
#include "astClasses/YAGICallbackConnector.h"
#include "../common/ASTNodeTypes/ASTNodeBase.h"
#include "../utils/make_unique.h"

#include <readline/readline.h>
#include <readline/history.h>

#include "astVisitors/ToStringVisitor.h"

//#pragma GCC diagnostic error "-Wuninitialized"
//    foo(a);         /* error is given for this one */
//#pragma GCC diagnostic push
//#pragma GCC diagnostic ignored "-Wuninitialized"
//    foo(b);         /* no diagnostic for this one */
//#pragma GCC diagnostic pop
//   foo(c);         /* error is given for this one */
//#pragma GCC diagnostic pop
//    foo(d);         /* depends on command line options *

bool execute(const std::string&);
std::string parseFileName(const std::string&);

int main(int argc, char * argv[])
{
  YAGICallbackConnector::connectCallbacks();

  std::string line;
  do
  {
    line = readline("YAGI>> ");
    add_history(line.c_str());
  }
  while (execute(line));

  return EXIT_SUCCESS;
}

bool isPrefixOf(const std::string& potentialPrefix, const std::string& text)
{
  auto res = std::mismatch(std::begin(potentialPrefix), std::end(potentialPrefix),
      std::begin(text));

  return (res.first == std::end(potentialPrefix));
}

bool execute(const std::string& line)
{
  if (line == "exit")
  {
    return false;
  }

  //using Antlr3InputStreamType = std::unique_ptr<pANTLR3_INPUT_STREAM, std::function<void(pANTLR3_INPUT_STREAM)>>;
  pANTLR3_INPUT_STREAM input = nullptr;

  using BufferType = std::unique_ptr<char[], std::function<void(char*)>>;
  BufferType antlrInputBuffer;

  if (isPrefixOf(std::string { "import" }, line))
  {
    std::string fname = parseFileName(line);

    input = antlr3FileStreamNew((pANTLR3_UINT8) fname.c_str(),
    ANTLR3_ENC_8BIT);

//    input = Antlr3InputStreamType(antlr3FileStreamNew((pANTLR3_UINT8) fname.c_str(),
//        ANTLR3_ENC_8BIT), [](pANTLR3_INPUT_STREAM st){st->close(st);});

    if (input == nullptr)
    {
      std::cout << "Can't load file '" << fname << "'!" << std::endl;
      return true;
    }
  }
  else
  {
    antlrInputBuffer = BufferType(strdup(line.c_str()), [](char* ptr)
    { free(ptr);});

    input = antlr3StringStreamNew((unsigned char*) antlrInputBuffer.get(),
    ANTLR3_ENC_8BIT, strlen(antlrInputBuffer.get()), (unsigned char*) "yagi-shell-input");
  }

  pYAGILexer lxr = YAGILexerNew(input);
  if (lxr == nullptr)
  {
    std::cout << "Can't create lexer!" << std::endl;
    return true;
  }

  pANTLR3_COMMON_TOKEN_STREAM tstream = antlr3CommonTokenStreamSourceNew(
  ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

  if (tstream == nullptr)
  {
    std::cout << "Can't create token stream!" << std::endl;
    return true;
  }

  pYAGIParser psr = YAGIParserNew(tstream);
  if (psr == nullptr)
  {
    std::cout << "Can't create parser!" << std::endl;
    return true;
  }

  auto langAST = psr->program(psr);
  std::cout << "C AST: " << langAST.tree->toStringTree(langAST.tree)->chars << std::endl;

  if (psr->pParser->rec->state->errorCount > 0)
  {
    fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n",
        psr->pParser->rec->state->errorCount);

  }
  else
  {
    pANTLR3_COMMON_TREE_NODE_STREAM nodes = antlr3CommonTreeNodeStreamNewTree(langAST.tree,
    ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!

    pYAGITreeWalker treePsr;
    treePsr = YAGITreeWalkerNew(nodes);
    treePsr->program(treePsr);

    auto ast = ASTBuilder::getInstance().getAST();

    auto toStringVisitor = std::make_shared<ToStringVisitor>();
    ast->accept(toStringVisitor.get());

    ASTBuilder::getInstance().reset();
  }

  if (psr)
  {
    psr->free(psr);
    psr = NULL;
  }

  if (tstream)
  {
    tstream->free(tstream);
    tstream = NULL;
  }

  if (lxr)
  {
    lxr->free(lxr);
    lxr = NULL;
  }

  if (input)
  {
    input->close(input);
    input = NULL;
  }

  return true;
}

std::string parseFileName(const std::string& importCmd)
{
  int first = importCmd.find_first_of('\"');
  int last = importCmd.find_last_of('\"');

  return importCmd.substr(first + 1, last - first - 1);
}
